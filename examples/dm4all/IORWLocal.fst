module IORWLocal

module List = FStar.List

(* Reasoning about IO, considering both inputs and outputs. With access
 * to the history of previous events and postcondition over the events
 * generated by the program, in update monad style. *)

type input = int
type output = int

noeq
type io a =
  | Read    : (input -> io a) -> io a
  | Write   : output -> io a -> io a
  | Return  : a -> io a

let return (a:Type u#a) (x:a) = Return x

let rec bind (a : Type u#aa) (b : Type u#bb)
         (l : io a) (k : a -> io b) : io b =
  match l with
  | Read f -> Read (fun i -> FStar.WellFounded.axiom1 f i; bind _ _ (f i) k)
  | Write o k' -> Write o (bind _ _ k' k)
  | Return v -> k v

type event =
  | In  : input -> event
  | Out : output -> event

let h_trace = list event
let l_trace = list event

let post a = a -> l_trace -> Type0
let wpty a = h_trace -> post a -> Type0

unfold
let return_wp (a:Type) (x:a) : wpty a =
  fun h p -> p x []

unfold
let bind_wp (_ : range) (a:Type) (b:Type) (w : wpty a) (kw : a -> wpty b) : wpty b =
  fun h p -> w h (fun x l -> kw x (h @ l) (fun y l' -> p y (l @ l')))

let rec interpretation #a (m : io a) (h : h_trace) (p : post a) : Type0 =
  match m with
  | Write o m -> interpretation m (h @ [Out o]) (fun x l -> p x ((Out o) :: l))
  | Read f -> forall (i : input). (FStar.WellFounded.axiom1 f i;
                                   interpretation (f i) (h @ [In i]) (fun x l -> p x ((In i) :: l)))
  | Return x -> p x []

total
reifiable
reflectable
new_effect {
  IO : a:Type -> Effect
  with
       repr      = io
     ; return    = return
     ; bind      = bind

     ; wp_type   = wpty
     ; return_wp = return_wp
     ; bind_wp   = bind_wp

     ; interp = interpretation
}

val read : unit -> IO int (fun h p -> forall x. p x [In x])
let read () =
    IO?.reflect (Read (fun i -> Return i))

val write : o:int -> IO unit (fun h p -> p () [Out o])
let write i =
    IO?.reflect (Write i (Return ()))

let test1 () : IO int (fun h p -> p 1 [Out 2; Out 3]) =
  write 2;
  write 3;
  1

let test2 () : IO int (fun h p -> forall i . p 1 [Out 2; In i; Out 3]) =
  write 2;
  let x = read () in
  write 3;
  1

effect Io (a:Type) (pre':h_trace -> Type0) (post':h_trace -> a -> l_trace -> Type0) =
        IO a (fun h p -> pre' h /\ (forall r l . post' h r l ==> p r l))

let test3 (i:int)
  : Io int (requires (fun h     -> exists h' h'' . h = h' @ (In i :: h'')))
           (ensures  (fun h x l -> exists x . l = [Out i; In x; Out x])) =
  write i;
  let x = read () in
  write x;
  1

let rec n_w_events (n:nat) (i:int) =
  if n = 0
  then []
  else Out i :: n_w_events (n - 1) i

let rec test4 (n:nat) (i:int)
  : Io unit (requires (fun _     -> True))
            (ensures  (fun h x l -> l = n_w_events n i)) =
  if n = 0
  then ()
  else (write i; test4 (n - 1) i)

let mustHaveOccurred (i:int) : IO unit (fun h p -> List.memP (Out i) h /\ p () []) =
  ()

(* Needed to have z3 prove `memP (Out x) (h @ [Out x])`, but
 * how is this not standard? *)
val lem_memP_append (#a:Type) (x y :a) (l : list a)
   : Lemma (List.memP x (l @ [y]) <==> List.memP x l \/ x == y)
           [SMTPat (List.memP x (l @ [y]))]
let rec lem_memP_append #a x y l =
  match l with
  | [] -> ()
  | _::t -> lem_memP_append x y t

let print_increasing (i:int) : IO unit (fun h p -> p () [Out i; Out (i+1)]) =
  write i;
  mustHaveOccurred i;
  write (i+1)

(* weaker spec *)
let print_increasing' (i:int) : IO unit (fun h p -> forall h'. p () h') =
  write i;
  mustHaveOccurred i;
  write (i+1)

(* won't work *)
[@expect_failure]
let print_increasing'' (i:int) : IO unit (fun h p -> forall h'. p () h') =
  mustHaveOccurred i;
  write (i+1)
  
(* won't work *)
[@expect_failure]
let print_increasing''' (i:int) : IO unit (fun h p -> forall h'. p () h') =
  mustHaveOccurred i;
  write i;
  write (i+1)
  
(* won't work *)
[@expect_failure]
let print_increasing'''' (i:int) : IO unit (fun h p -> forall h'. p () h') =
  write (i+1);
  mustHaveOccurred i;
  write i
