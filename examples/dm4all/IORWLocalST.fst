module IORWLocalST

module List = FStar.List

(* Reasoning about the combination of IO and state, considering both  
 * inputs and outputs. Postconditions are over final states and 
 * the events generated by the program, and the computed preconditions
 * are over initial states and the history of previous events. 
 * The computational monad is the tensor of state and IO (equivalently, 
 * the state monad transformer applied to the IO monad). *)

type input = int
type output = int

type state = int

noeq
type io a =
  | Read    : (input -> io a) -> io a
  | Write   : output -> io a -> io a
  | Return  : a -> io a

let iost a = state -> io (a * state)

let return (a:Type u#a) (x:a) : iost a = 
  fun s -> Return (x,s)

let rec bind_rec (a : Type u#aa) (b : Type u#bb)
         (l : io (a * state)) (k : a -> iost b) (s:state) : io (b * state) =
  match l with 
    | Read f -> Read (fun i -> FStar.WellFounded.axiom1 f i; bind_rec _ _ (f i) k s)
    | Write o k' -> Write o (bind_rec _ _ k' k s)
    | Return (v,s') -> k v s'

let bind (a : Type u#aa) (b : Type u#bb)
         (l : iost a) (k : a -> iost b) : iost b =
  fun s -> bind_rec a b (l s) k s

type event =
  | In  : input -> event
  | Out : output -> event

let h_trace = list event
let l_trace = list event

let post a = a -> state * l_trace -> Type0
let wpty a = state -> h_trace -> post a -> Type0

unfold
let return_wp (a:Type) (x:a) : wpty a =
  fun s h p -> p x (s,[])

unfold
let bind_wp (_ : range) (a:Type) (b:Type) (w : wpty a) (kw : a -> wpty b) : wpty b =
  fun s h p -> w s h (fun x (s',l) -> kw x s' (h @ l) (fun y (s'',l') -> p y (s'',l @ l')))

let rec interpretation_rec #a (m : io (a * state)) (s : state) (h : h_trace) (p : post a) : Type0 =
  match m with
  | Write o m -> interpretation_rec m s (h @ [Out o]) (fun x (s',l) -> p x (s',(Out o) :: l))
  | Read f -> forall (i : input). 
                (FStar.WellFounded.axiom1 f i;
                 interpretation_rec (f i) s (h @ [In i]) (fun x (s',l) -> p x (s',(In i) :: l)))
  | Return (x,s') -> p x (s',[])

let interpretation #a (m : iost a) (s : state) (h : h_trace) (p : post a) : Type0 =
  interpretation_rec (m s) s h p

total
reifiable
reflectable
new_effect {
  IOST : a:Type -> Effect
  with
       repr      = iost
     ; return    = return
     ; bind      = bind

     ; wp_type   = wpty
     ; return_wp = return_wp
     ; bind_wp   = bind_wp

     ; interp = interpretation
}


val read : unit -> IOST int (fun s h p -> forall x. p x (s,[In x]))
let read () =
    IOST?.reflect (fun s -> Read (fun i -> Return (i,s)))

val write : o:int -> IOST unit (fun s h p -> p () (s,[Out o]))
let write i =
    IOST?.reflect (fun s -> Write i (Return ((),s)))

val get : unit -> IOST state (fun s h p -> p s (s,[]))
let get () =
    IOST?.reflect (fun s -> Return (s,s))

val put : s:state -> IOST unit (fun _ h p -> p () (s,[]))
let put s =
    IOST?.reflect (fun _ -> Return ((),s))

let test1 () : IOST int (fun s h p -> p 1 (s,[Out 2; Out 3])) =
  write 2;
  write 3;
  1

let test2 () : IOST int (fun s h p -> forall i . p 1 (s,[Out 2; In i; Out 3])) =
  write 2;
  let x = read () in
  write 3;
  1

let mustHaveOccurred (i:int) : IOST unit (fun s h p -> List.memP (Out i) h /\ p () (s,[])) =
  ()

(* Needed to have z3 prove `memP (Out x) (h @ [Out x])`, but
 * how is this not standard? *)
val lem_memP_append (#a:Type) (x y :a) (l : list a)
   : Lemma (List.memP x (l @ [y]) <==> List.memP x l \/ x == y)
           [SMTPat (List.memP x (l @ [y]))]
let rec lem_memP_append #a x y l =
  match l with
  | [] -> ()
  | _::t -> lem_memP_append x y t

let print_increasing (i:int) : IOST unit (fun s h p -> p () (s,[Out i; Out (i+1)])) =
  write i;
  mustHaveOccurred i;
  write (i+1)

(* weaker spec *)
let print_increasing' (i:int) : IOST unit (fun s h p -> forall h'. p () (s,h')) =
  write i;
  mustHaveOccurred i;
  write (i+1)

(* won't work *)
[@expect_failure]
let print_increasing'' (i:int) : IOST unit (fun s h p -> forall h'. p () (s,h')) =
  mustHaveOccurred i;
  write (i+1)
  
(* won't work *)
[@expect_failure]
let print_increasing''' (i:int) : IOST unit (fun s h p -> forall h'. p () (s,h')) =
  mustHaveOccurred i;
  write i;
  write (i+1)
  
(* won't work *)
[@expect_failure]
let print_increasing'''' (i:int) : IOST unit (fun s h p -> forall h'. p () (s,h')) =
  write (i+1);
  mustHaveOccurred i;
  write i

let test3 () : IOST int (fun s h p -> forall i . p 1 (i,[In i])) =
  let x = read () in
  put x;
  1

let test4 () : IOST int (fun s h p -> p 1 (s,[Out s])) =
  let x = get () in
  write x;
  1

let test5 () : IOST int (fun s h p -> forall i . p 1 (i,[In i;Out (i+1)])) =
  let x = read () in
  put x;
  let y = get () in 
  write (y+1);
  1

let test6 () : IOST int (fun s h p -> forall i . p 1 (s,[In i;Out (s+i+1)])) =
  let x = get () in 
  let y = read () in
  put (x+y);
  let z = get () in 
  write (z+1);
  put x;
  1
